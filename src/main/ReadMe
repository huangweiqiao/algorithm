常见的排序算法有：
插入排序
    直接插入排序，希尔排序

选择排序
    简单选择排序，堆排序

交换排序
    冒泡排序，快速排序

归并排序

基数排序

比较和非比较的区别：
    常见的快速排序、归并排序、堆排序、冒泡排序都是比较排序，在排序的最终结果里，元素之间的次序依赖于它们之间的比较。
        每个数都必须和其他数进行比较，才能确定自己的位置。
        在冒泡排序之类的排序中，问题规模是n,又因为需要比较n次，所以平均时间复杂度为O(n2),
        在快速排序和归并排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均为O(nlogn),
        比较排序的优势就是适用各种规模的数据，也不在乎数据的分布，适用于一切需要排序的情况。

    常见的计算排序、基数排序、桶排序都是非比较排序，
        非比较排序是通过确定每个元素之前应该有多少个元素来排序，针对数组arr,
        计算数组arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。
        非比较排序只要确定每个元素之前的已有的元素个数即可，所以一次便利就可解决。算法时间复杂度为O(n)。
        非比较排序时间复杂度低，但非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。



树
一、为什么要树
有序数组插入数据和删除数据慢，链表查找数据太慢，
在树中能快速的查找数据项、插入数据项和删除数据项。

路径
顺着链接节点的边从一个节点到另一个节点，所经过的节点顺序排列称为路径

根
树最上面的节点称为根节点，一棵树只有一个根，而且从根节点到任何节点有且只有一条路径。

父节点
每一个节点都有一条边向上连接到另一个节点，这个节点就称为是下面这个节点的父节点。

子节点
每一个节点都有一条边向下连接到另外一个节点，下面这个节点就是该节点的子节点。

叶子节点
没有子节点的节点就是叶子节点

子树
每个节点都可以作为一个子树的根，它和它所有的子节点、子节点的子节点组合在一起就是一个子树

访问
访问一个节点是为了在这个节点上执行一些操作，如查看节点的数据项，但是如果仅仅是经过一个节点，不认为是访问了这个节点。

层
一个节点的层数是指从根开始到这个节点有多少代。

二叉树
树的每个节点最多只能有两个子节点的树，成为二叉树。


















