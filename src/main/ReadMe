常见的排序算法有：
插入排序
    直接插入排序，希尔排序

选择排序
    简单选择排序，堆排序

交换排序
    冒泡排序，快速排序

归并排序

基数排序

比较和非比较的区别：
    常见的快速排序、归并排序、堆排序、冒泡排序都是比较排序，在排序的最终结果里，元素之间的次序依赖于它们之间的比较。
        每个数都必须和其他数进行比较，才能确定自己的位置。
        在冒泡排序之类的排序中，问题规模是n,又因为需要比较n次，所以平均时间复杂度为O(n2),
        在快速排序和归并排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均为O(nlogn),
        比较排序的优势就是适用各种规模的数据，也不在乎数据的分布，适用于一切需要排序的情况。

    常见的计算排序、基数排序、桶排序都是非比较排序，
        非比较排序是通过确定每个元素之前应该有多少个元素来排序，针对数组arr,
        计算数组arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。
        非比较排序只要确定每个元素之前的已有的元素个数即可，所以一次便利就可解决。算法时间复杂度为O(n)。
        非比较排序时间复杂度低，但非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。



树
一、为什么要树
有序数组插入数据和删除数据慢，链表查找数据太慢，
在树中能快速的查找数据项、插入数据项和删除数据项。

路径
顺着链接节点的边从一个节点到另一个节点，所经过的节点顺序排列称为路径

根
树最上面的节点称为根节点，一棵树只有一个根，而且从根节点到任何节点有且只有一条路径。

父节点
每一个节点都有一条边向上连接到另一个节点，这个节点就称为是下面这个节点的父节点。

子节点
每一个节点都有一条边向下连接到另外一个节点，下面这个节点就是该节点的子节点。

叶子节点
没有子节点的节点就是叶子节点

子树
每个节点都可以作为一个子树的根，它和它所有的子节点、子节点的子节点组合在一起就是一个子树

访问
访问一个节点是为了在这个节点上执行一些操作，如查看节点的数据项，但是如果仅仅是经过一个节点，不认为是访问了这个节点。

层
一个节点的层数是指从根开始到这个节点有多少代。

二叉树
树的每个节点最多只能有两个子节点的树，成为二叉树。

红黑树
1、二叉树的问题
普通的二叉树作为数据存储工具有很大的优势，可以快速的插入、删除和查找数据项，遗憾的是，这仅仅是相对于插入随机数据，
如果插入的数据是有序的，速度就变得特别慢了。


2、平衡树和非平衡树
插入随机的数据，平衡树
插入有序的数据，非平衡树


3、红黑规则
一、每个节点不是红色就是黑色的
二、根总是黑色的
三、如果节点是红色的，则它的子节点必须是黑色的
四、从根节点到叶子节点的每条路径，必须包含相同数目的黑色节点

4、使一颗不符合红黑规则的树转换成红黑树可以从两点着手
一、改变节点的颜色
二、执行旋转操作




哈希表
解决冲突的方法有：开放地址法、链地址法

什么是开放地址法
当冲突发生时，通过查找数组的一个空位，并将数据填入，而不再用哈希函数得到的数组下标，这个方法叫做开放地址法。

什么时链地址法
在哈希表每个单元中设置链表，某个数据项的关键字还是像通常一样映射到哈希表的单元中，而数据项本身插入到单元的链表中


图
图是一种和树相像的数据结构，通常有一个固定的形状，这是由物理或抽象的问题来决定的

邻接
如果两个顶点被同一条边连接，就称这两个顶点是邻接的

路径
路径是从一个顶点到另一个顶点经过的边的序列

连通图和非连通图
至少有一条路径可以连接所有的顶点，那么这个图就是连通的，否则是非连通图，
非连通图包含多个子图，子图是连通图。

有向图和无向图
有向图的边是有方向的，如只能从A到B，不能从B到A。
无向图的边是没有方向的，可以从A到B，也可以从B到A。

带权图
在有些图中，边被赋予了一个权值，权值是一个数字，它可以代表如两个顶点的物理距离，
或者是一个顶点到另一个顶点的时间等等，这样的图叫做带权图。


图的搜索
图的搜索是指从一个指定顶点可以到达哪些顶点


搜索的分类
深度优先搜索DFS
广度优先搜索BFS


深度优先搜索规则
1、如果可能，访问一个邻接的未访问过的顶点，标记它为已访问，并把它放入栈中
（继续访问该顶点的未访问过的邻接，以此类推直到最深的那个邻接点）。
2、当不能执行规则1时，如果栈不为空，就从栈中弹出一个顶点
（对弹出来的顶点继续执行规则1，如果不满足规则1则继续从栈中弹出一个顶点）。
3、当不能执行规则1和规则2，就完成了整个搜索过程。


广度优先搜索规则
1、访问下一个邻接的未访问过的顶点，这个顶点必须是当前节点的邻接点，标记它访问过，并把它插入队列中。
2、如果无法执行规则1，那么就从队列头取出一个顶点，并使其作为当前的顶点。
3、当队列为空不能执行规则2时，就完成了整个搜索过程。


图的最小生成树
连接每个顶点最少的连线，最小生成树边的数量总是比顶点的数量少1













